import streamlit as st
from pathlib import Path
import pandas as pd
import numpy as np
import time
import re
import ast
import sqlite3
import matplotlib.pyplot as plt
import json

from langchain_community.agent_toolkits.sql.base import create_sql_agent
from langchain_community.utilities import SQLDatabase
from langchain_community.callbacks.streamlit import StreamlitCallbackHandler
from langchain_community.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain_core.prompts import PromptTemplate
from langchain.agents.agent_types import AgentType
from langchain_groq import ChatGroq

from sqlalchemy import create_engine, inspect, text

st.set_page_config(page_title="SmartSQL: NL-to-SQL", layout="wide", page_icon="ðŸ”")

st.title("ðŸ” SmartSQL: Natural Language Database Interface")

col1, col2 = st.columns([0.8, 4])

with col1:
    logo_path = "C:/Users/prach/Desktop/sql.webp"
    try:
        st.image(logo_path, width=150)
    except Exception as img_e:
         st.warning(f"Could not load image: {img_e}. Ensure path is correct.")

with col2:
    st.markdown("### Bridging natural language and database queries")
    st.markdown("*Ask questions about your data in plain English*")
    st.markdown("_(Using schema from `student.db`)_")

st.divider()

st.sidebar.title("âš™ï¸ Configuration")

st.sidebar.header("Database")
st.sidebar.info("Using `student.db` generated by `sqlite.py`.")
selected_opt = "Use SQLite 3 Database"
db_uri = "USE_SQLITE"
db_details = {}

st.sidebar.divider()

st.sidebar.header("ðŸ¤– Model")
model_options = ["Llama3-8b-8192", "Llama3-70b-8192", "mistral-saba-24b"]
selected_model = st.sidebar.selectbox("Select LLM Model", options=model_options)

api_key_input = st.sidebar.text_input("Groq API Key", type="password", help="Get your free API key from console.groq.com")
api_key = api_key_input.strip() if api_key_input else None

st.sidebar.divider()

with st.sidebar.expander("ðŸ”§ Advanced Settings"):
    show_reasoning = st.checkbox("Show LLM reasoning", value=True, help="Display the agent's step-by-step thinking process.")
    query_validation = st.checkbox("Enable query pre-validation", value=False, help="Uses an extra LLM call to check if the question is likely SQL-translatable.")
    performance_tracking = st.checkbox("Track query performance", value=True, help="Log execution time and success rate for the session.")
    schema_cache_ttl = st.slider("Schema cache TTL (hours)", min_value=0, max_value=24, value=1, help="How long to cache the database schema (0=disable).")

with st.sidebar.expander("ðŸ’¡ Example Queries"):
    st.markdown("- List students in section B")
    st.markdown("- What courses are taught by teacher ID 3?")
    st.markdown("- Show names and marks for students in the 'Algorithms' course")
    st.markdown("- Find the average marks for the 'CS' class using the student_performance view")
    st.markdown("- List teachers in the 'Computer Science' department")
    st.markdown("- Show STUDENT_NAME and MARKS from student_performance where GRADE is 'A'")
    st.markdown("- Show NAME and EMAIL from TEACHER table")

st.sidebar.divider()

if st.sidebar.button("ðŸ—‘ï¸ Clear Conversation"):
    st.session_state["messages"] = [{"role": "assistant", "content": "Conversation cleared. How can I help?"}]
    if "performance_log" in st.session_state:
         st.session_state.performance_log = []
    st.cache_resource.clear()
    st.rerun()


if not api_key:
     st.warning("Please provide the Groq API key in the sidebar.")
     st.stop()

try:
    llm = ChatGroq(
        groq_api_key=api_key,
        model_name=selected_model,
        streaming=False,
        temperature=0.2
    )
except Exception as llm_e:
    st.error(f"Failed to initialize LLM. Check API Key and model selection: {llm_e}")
    st.stop()


@st.cache_resource(ttl=f"{schema_cache_ttl}h")
def configure_db(db_uri_arg, db_config_arg):
    engine = None
    db_obj = None
    dbfilepath = (Path(__file__).parent / "student.db").absolute()

    if db_uri_arg == "USE_SQLITE":
        if not dbfilepath.exists():
             st.error(f"Error: student.db not found at {dbfilepath}. Please run `sqlite.py` first.")
             raise FileNotFoundError("student.db not found. Run `sqlite.py` first.")
        try:
            creator = lambda: sqlite3.connect(f"file:{dbfilepath}?mode=rw", uri=True)
            engine = create_engine("sqlite:///", creator=creator)
            db_obj = SQLDatabase(engine)
        except Exception as connect_e:
            st.error(f"Failed to connect to student.db: {connect_e}")
            raise connect_e
    else:
        st.error(f"Unsupported database type selected: {db_uri_arg}")
        raise ValueError(f"Invalid database type: {db_uri_arg}")

    schema_info = {}
    if engine and db_obj:
        try:
            with engine.connect() as connection:
                 inspector = inspect(engine)
                 all_tables = inspector.get_table_names()
                 all_views = inspector.get_view_names()
                 all_tables_and_views = all_tables + all_views

            if not all_tables_and_views:
                 st.warning(f"Database '{dbfilepath.name}' connected, but contains no tables or views.")
            else:
                for name in all_tables_and_views:
                    is_view = name in all_views
                    columns = inspector.get_columns(name)
                    schema_info[name] = {
                        "columns": [col["name"] for col in columns],
                        "types": {col["name"]: str(col["type"]) for col in columns},
                        "is_view": is_view
                    }
                    if not is_view:
                        try:
                            foreign_keys = inspector.get_foreign_keys(name)
                            if foreign_keys: schema_info[name]["foreign_keys"] = foreign_keys
                        except NotImplementedError: pass
        except Exception as schema_e:
            st.warning(f"Could not inspect schema: {schema_e}")
            return db_obj, {}
    else:
         st.error("Database engine or DB object not created.")
         raise ConnectionError("Failed to initialize database engine/object.")

    return db_obj, schema_info

db = None
schema_info = {}
agent = None
toolkit = None

try:
    with st.spinner("Connecting to database & analyzing schema..."):
        db, schema_info = configure_db(db_uri, db_details)

    st.subheader("ðŸ“– Database Schema")
    with st.expander("View Schema Details", expanded=False):
        if schema_info:
            for name, details in schema_info.items():
                view_label = " (View)" if details.get("is_view") else ""
                st.markdown(f"**Table/View: `{name}`{view_label}**")
                columns_df = pd.DataFrame({
                    "Column": [f"`{col}`" for col in details["columns"]],
                    "Type": [details["types"][col] for col in details["columns"]]
                })
                st.markdown(columns_df.to_markdown(index=False), unsafe_allow_html=True)

                if "foreign_keys" in details:
                    st.markdown("**Foreign Keys:**")
                    for fk in details["foreign_keys"]:
                        constrained = [f"`{c}`" for c in fk.get('constrained_columns', [])]
                        referred_cols = [f"`{c}`" for c in fk.get('referred_columns', [])]
                        referred_table = f"`{str(fk.get('referred_table', ''))}`"
                        st.markdown(f"- {', '.join(constrained)} â†’ {referred_table}.({', '.join(referred_cols)})")
                st.markdown("---")
        elif db:
             st.warning("Connected to DB, but no schema information was retrieved.")
        else:
             st.error("Database connection failed. Cannot display schema.")

    if db:
        try:
            toolkit = SQLDatabaseToolkit(db=db, llm=llm)
            agent = create_sql_agent(
                llm=llm,
                toolkit=toolkit,
                verbose=show_reasoning,
                agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
                handle_parsing_errors=True,
                top_k=10,
            )

        except Exception as agent_init_e:
             st.error(f"Failed to initialize LangChain Agent: {agent_init_e}")
             agent = None
    else:
        st.error("Database not connected. Agent initialization skipped.")
        agent = None

except Exception as setup_e:
    st.error(f"Critical Error during Setup: {str(setup_e)}")
    st.stop()


if "performance_log" not in st.session_state:
    st.session_state.performance_log = []
if "messages" not in st.session_state:
     st.session_state["messages"] = [{"role": "assistant", "content": "Hi! How can I help you query the student database today?"}]


st.subheader("ðŸ’¬ Conversation")
chat_container = st.container(height=400, border=False)
with chat_container:
    for i, msg in enumerate(st.session_state.messages):
        with st.chat_message(msg["role"]):
            if msg["role"] == "assistant" and i == len(st.session_state.messages) - 1:
                 if isinstance(msg["content"], str) and ("Action:" in msg["content"] or "Final Answer:" in msg["content"] or "```sql" in msg["content"]):
                      display_agent_output(msg["content"])
                 else:
                      st.markdown(msg["content"])
            else:
                 st.markdown(msg["content"])


reasoning_placeholder = st.empty()

def display_agent_output(response_content):
    st.markdown("---")

    sql_pattern = r"```sql\n(.*?)\n```"
    data_pattern = r"(\[(?:'[^']*'|\"[^\"]*\"|\d+\.?\d*|None|True|False|\s*\(.*?\)|\[.*?\])(?:,\s*(?:'[^']*'|\"[^\"]*\"|\d+\.?\d*|None|True|False|\s*\(.*?\)|\[.*?\]))*\])"

    sql_match = re.search(sql_pattern, response_content, re.DOTALL)
    data_match = re.search(data_pattern, response_content)

    remaining_content = response_content
    sql_query = None
    data_list = None

    if sql_match:
        sql_query = sql_match.group(1).strip()
        st.write("ðŸ’¾ **Generated SQL Query:**")
        st.code(sql_query, language="sql")
        remaining_content = remaining_content.replace(sql_match.group(0), "").strip()

    if data_match:
        data_string = data_match.group(1)
        st.write("ðŸ“Š **Query Result:**")
        try:
            data_list = ast.literal_eval(data_string)
            if isinstance(data_list, list) and data_list:
                 if isinstance(data_list[0], (list, tuple)):
                     try:
                         df = pd.DataFrame(data_list)
                         cols = None
                         if sql_query:
                            col_match = re.search(r"SELECT\s+(?:DISTINCT\s+)?(.*?)\s+FROM", sql_query, re.IGNORECASE | re.DOTALL)
                            if col_match:
                                try:
                                    raw_cols = col_match.group(1).strip()
                                    parsed_cols = []
                                    for c in re.split(r',(?![^\(]*\))', raw_cols):
                                        alias_parts = re.split(r'\s+as\s+', c.strip(), flags=re.IGNORECASE)
                                        col_name = alias_parts[-1].strip().split('.')[-1].strip('`"\'')
                                        parsed_cols.append(col_name)
                                    cols = parsed_cols
                                    if len(cols) == len(df.columns): df.columns = cols
                                    else: st.caption(f"Headers inferred ({len(df.columns)} found).")
                                except Exception: st.caption("Headers inferred.")
                         st.dataframe(df, hide_index=True, use_container_width=True)
                     except Exception as df_e:
                         st.warning(f"Could not display as table ({df_e}). Raw data:")
                         st.text(data_string)
                 else:
                     st.text(str(data_list))
            elif isinstance(data_list, list) and not data_list:
                 st.write("_(Query returned no results)_")
            else:
                 st.text(str(data_list))
            remaining_content = remaining_content.replace(data_match.group(0), "").strip()
        except (ValueError, SyntaxError) as parse_e:
            st.warning(f"Could not parse results data string: {parse_e}")
            st.text(data_string)
            remaining_content = remaining_content.replace(data_match.group(0), "").strip()

    final_explanation = remaining_content.strip()
    if final_explanation:
        is_empty_result = (data_match and data_list is not None and isinstance(data_list, list) and not data_list)
        if not (is_empty_result and ("no results" in final_explanation.lower() or "empty" in final_explanation.lower())):
             st.write("â„¹ï¸ **Explanation:**")
             st.markdown(final_explanation)


user_query = st.chat_input(
    placeholder="Ask about students, courses, teachers, or grades..." if agent else "Agent not ready. Check config/connection.",
    disabled=(agent is None)
)

if user_query and agent:
    st.session_state.messages.append({"role": "user", "content": user_query})
    with chat_container:
        with st.chat_message("user"):
            st.markdown(user_query)

    validated_query = user_query
    if query_validation:
        validation_prompt = PromptTemplate(
            template="Does the following question seem like a request for data from a database? Answer YES or NO: '{query}'",
            input_variables=["query"]
        )
        try:
            validation_llm = ChatGroq(groq_api_key=api_key, model_name="Llama3-8b-8192", temperature=0)
            validation_chain = validation_prompt | validation_llm
            with st.spinner("Validating query..."):
                try:
                    validation_response = validation_chain.invoke({"query": user_query})
                    validation_result = validation_response.content.strip().upper()
                except Exception as validation_e:
                    st.warning(f"Query validation call failed: {validation_e}. Proceeding.")
                    validation_result = "YES"

            if "NO" in validation_result:
                error_message = "This question doesn't seem like a database query. Please ask for specific data (e.g., 'List students...', 'What is the average...', 'Count courses...')."
                st.session_state.messages.append({"role": "assistant", "content": error_message})
                with chat_container:
                     with st.chat_message("assistant"):
                         st.warning(error_message)
                validated_query = None
        except Exception as val_llm_e:
             st.warning(f"Could not initialize validation LLM: {val_llm_e}. Skipping validation.")

    if validated_query:
        start_time = time.time()
        response_content = "Agent execution did not produce content."
        error_occurred = False
        processed_output_displayed = False

        with chat_container:
            with st.chat_message("assistant"):
                placeholder = st.empty()
                reasoning_expander_placeholder = st.empty()

                if not show_reasoning:
                     placeholder.markdown("ðŸ§  Processing your query...")

                try:
                    callbacks = []
                    reasoning_container = None
                    if show_reasoning:
                        with reasoning_placeholder.expander("ðŸ¤” Agent Reasoning Steps", expanded=True):
                             reasoning_container = st.container()
                             streamlit_callback = StreamlitCallbackHandler(
                                 parent_container=reasoning_container,
                                 collapse_completed_thoughts=True,
                                 expand_new_thoughts=True
                             )
                             callbacks.append(streamlit_callback)

                    response_content = agent.run(validated_query, callbacks=callbacks)

                    if not show_reasoning and placeholder: placeholder.empty()

                    with placeholder.container():
                        display_agent_output(response_content)
                        processed_output_displayed = True

                except Exception as e:
                    error_occurred = True
                    error_details = f"**Error:**\nAgent execution failed.\n\n*Type:* `{type(e).__name__}`\n*Details:*\n```\n{str(e)}\n```"
                    if placeholder:
                         placeholder.error(error_details)
                    else:
                         st.error(error_details)

                    response_content = error_details
                    print(f"AGENT EXECUTION ERROR: {e}")
                    import traceback
                    traceback.print_exc()

                finally:
                    end_time = time.time()
                    execution_time = end_time - start_time

                    if performance_tracking:
                         st.session_state.performance_log.append({
                            "query": validated_query, "execution_time": execution_time,
                            "timestamp": end_time, "success": not error_occurred
                         })

                    if not error_occurred and placeholder:
                        with placeholder.container():
                            if not processed_output_displayed:
                                 display_agent_output(response_content)
                            st.caption(f"Response time: {execution_time:.2f} seconds")
                    elif not error_occurred:
                         st.caption(f"Response time: {execution_time:.2f} seconds")

                    final_content_to_log = response_content
                    st.session_state.messages.append({"role": "assistant", "content": final_content_to_log})


if performance_tracking and len(st.session_state.performance_log) > 0:
    st.divider()
    with st.expander("ðŸ“Š Query Performance Metrics (Current Session)", expanded=False):
        try:
            log_df = pd.DataFrame(st.session_state.performance_log)
            successful_queries = log_df[log_df['success'] == True]
            total_queries = len(log_df)
            avg_time = successful_queries['execution_time'].mean() if not successful_queries.empty else 0
            success_rate = (len(successful_queries) / total_queries * 100) if total_queries > 0 else 0

            m_col1, m_col2 = st.columns(2)
            with m_col1:
                st.metric("Queries This Session", total_queries)
                st.metric("Success Rate", f"{success_rate:.1f}%", help="Agent ran without throwing an error.")
            with m_col2:
                st.metric("Avg. Response Time (Successful)", f"{avg_time:.2f}s" if avg_time > 0 else "N/A")

            if not successful_queries.empty and len(successful_queries) > 1:
                st.markdown("**Response Time Trend (Successful Queries)**")
                chart_data = successful_queries[['execution_time']].reset_index(drop=True).rename(columns={'execution_time':'Response Time (s)'})
                st.line_chart(chart_data, use_container_width=True)
            elif not successful_queries.empty:
                 st.caption("Chart requires at least two successful queries.")
            else:
                st.caption("No successful queries logged yet.")
        except Exception as metrics_e:
             st.error(f"Failed to display performance metrics: {metrics_e}")

st.divider()
st.caption("*SmartSQL - Making databases speak human language*")